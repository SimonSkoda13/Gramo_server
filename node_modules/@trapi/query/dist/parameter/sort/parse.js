"use strict";
/*
 * Copyright (c) 2021.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQuerySort = void 0;
const utils_1 = require("../../utils");
const type_1 = require("./type");
// --------------------------------------------------
// --------------------------------------------------
function isMultiDimensionalArray(arr) {
    if (!Array.isArray(arr)) {
        return false;
    }
    return arr.length > 0 && Array.isArray(arr[0]);
}
/**
 * Transform sort data to appreciate data format.
 * @param data
 * @param options
 */
function parseQuerySort(data, options) {
    options = options !== null && options !== void 0 ? options : {};
    // If it is an empty array nothing is allowed
    if (Array.isArray(options.allowed) &&
        options.allowed.length === 0) {
        return [];
    }
    options.aliasMapping = options.aliasMapping ? (0, utils_1.buildObjectFromStringArray)(options.aliasMapping) : {};
    const prototype = Object.prototype.toString.call(data);
    /* istanbul ignore next */
    if (prototype !== '[object String]' &&
        prototype !== '[object Array]' &&
        prototype !== '[object Object]') {
        return [];
    }
    let parts = [];
    if (prototype === '[object String]') {
        parts = data.split(',');
    }
    if (prototype === '[object Array]') {
        parts = data.filter(item => typeof item === 'string');
    }
    if (prototype === '[object Object]') {
        const ob = data;
        for (const key in ob) {
            /* istanbul ignore next */
            if (!ob.hasOwnProperty(key) ||
                typeof key !== 'string' ||
                typeof ob[key] !== 'string')
                continue;
            const fieldPrefix = ob[key].toLowerCase() === 'desc' ? '-' : '';
            parts.push(fieldPrefix + key);
        }
    }
    const items = {};
    for (let i = 0; i < parts.length; i++) {
        let direction = type_1.SortDirection.ASC;
        if (parts[i].substr(0, 1) === '-') {
            direction = type_1.SortDirection.DESC;
            parts[i] = parts[i].substr(1);
        }
        let key = parts[i];
        if (options.aliasMapping.hasOwnProperty(key)) {
            key = options.aliasMapping[key];
        }
        const fieldDetails = (0, utils_1.getFieldDetails)(key);
        if (!(0, utils_1.isFieldAllowedByRelations)(fieldDetails, options.relations, { defaultAlias: options.defaultAlias })) {
            continue;
        }
        const keyWithAlias = (0, utils_1.buildFieldWithAlias)(fieldDetails, options.defaultAlias);
        if (typeof options.allowed !== 'undefined' &&
            !isMultiDimensionalArray(options.allowed) &&
            options.allowed.indexOf(key) === -1 &&
            options.allowed.indexOf(keyWithAlias) === -1) {
            continue;
        }
        const alias = typeof fieldDetails.path === 'undefined' &&
            typeof fieldDetails.alias === 'undefined' ?
            (options.defaultAlias ?
                options.defaultAlias :
                undefined)
            :
                fieldDetails.alias;
        items[keyWithAlias] = Object.assign(Object.assign({ key: fieldDetails.name }, (alias ? { alias } : {})), { value: direction });
    }
    if (isMultiDimensionalArray(options.allowed)) {
        outerLoop: for (let i = 0; i < options.allowed.length; i++) {
            const temp = [];
            for (let j = 0; j < options.allowed[i].length; j++) {
                const keyWithAlias = options.allowed[i][j];
                const key = keyWithAlias.includes('.') ? keyWithAlias.split('.').pop() : keyWithAlias;
                if (items.hasOwnProperty(key) || items.hasOwnProperty(keyWithAlias)) {
                    const item = items.hasOwnProperty(key) ? items[key] : items[keyWithAlias];
                    temp.push(item);
                }
                else {
                    continue outerLoop;
                }
            }
            return temp;
        }
        // if we get no match, the sort data is invalid.
        return [];
    }
    return Object.values(items);
}
exports.parseQuerySort = parseQuerySort;
//# sourceMappingURL=parse.js.map