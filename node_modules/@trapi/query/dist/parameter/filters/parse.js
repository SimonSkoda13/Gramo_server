"use strict";
/*
 * Copyright (c) 2021.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQueryFilters = void 0;
const utils_1 = require("../../utils");
const type_1 = require("./type");
// --------------------------------------------------
// --------------------------------------------------
function buildOptions(options) {
    var _a;
    options !== null && options !== void 0 ? options : (options = {});
    if (options.aliasMapping) {
        options.aliasMapping = (0, utils_1.buildObjectFromStringArray)(options.aliasMapping);
    }
    else {
        options.aliasMapping = {};
    }
    (_a = options.relations) !== null && _a !== void 0 ? _a : (options.relations = []);
    return options;
}
function parseQueryFilters(data, options) {
    var _a, _b, _c;
    options = options !== null && options !== void 0 ? options : {};
    // If it is an empty array nothing is allowed
    if (typeof options.allowed !== 'undefined' &&
        Object.keys(options.allowed).length === 0) {
        return [];
    }
    const prototype = Object.prototype.toString.call(data);
    /* istanbul ignore next */
    if (prototype !== '[object Object]') {
        return [];
    }
    const length = Object.keys(data).length;
    if (length === 0) {
        return [];
    }
    options = buildOptions(options);
    const temp = {};
    // transform to appreciate data format & validate input
    for (let key in data) {
        /* istanbul ignore next */
        if (!data.hasOwnProperty(key)) {
            continue;
        }
        let value = data[key];
        if (typeof value !== 'string' &&
            typeof value !== 'number' &&
            typeof value !== 'boolean') {
            continue;
        }
        if (typeof value === 'string') {
            value = value.trim();
            const stripped = value.replace('/,/g', '');
            if (stripped.length === 0) {
                continue;
            }
        }
        if (options.aliasMapping.hasOwnProperty(key)) {
            key = options.aliasMapping[key];
        }
        const fieldDetails = (0, utils_1.getFieldDetails)(key);
        if (!(0, utils_1.isFieldAllowedByRelations)(fieldDetails, options.relations, { defaultAlias: options.defaultAlias })) {
            continue;
        }
        const keyWithAlias = (0, utils_1.buildFieldWithAlias)(fieldDetails, options.defaultAlias);
        if (typeof options.allowed !== 'undefined' &&
            options.allowed.indexOf(key) === -1 &&
            options.allowed.indexOf(keyWithAlias) === -1) {
            continue;
        }
        const alias = typeof fieldDetails.path === 'undefined' &&
            typeof fieldDetails.alias === 'undefined' ?
            (options.defaultAlias ?
                options.defaultAlias :
                undefined)
            :
                fieldDetails.alias;
        temp[keyWithAlias] = Object.assign(Object.assign({ key: fieldDetails.name }, (alias ? { alias } : {})), { value: value });
    }
    const items = [];
    /* istanbul ignore next */
    for (const key in temp) {
        /* istanbul ignore next */
        if (!temp.hasOwnProperty(key)) {
            continue;
        }
        const filter = Object.assign(Object.assign({}, (temp[key].alias ? { alias: temp[key].alias } : {})), { key: temp[key].key, value: temp[key].value });
        if (typeof filter.value === 'string') {
            const negationOperator = filter.value.charAt(0) === type_1.FilterOperator.NEGATION;
            if (negationOperator) {
                (_a = filter.operator) !== null && _a !== void 0 ? _a : (filter.operator = {});
                filter.operator[type_1.FilterOperatorLabel.NEGATION] = negationOperator;
                filter.value = filter.value.slice(1);
            }
            const likeOperator = filter.value.charAt(0) === type_1.FilterOperator.LIKE;
            if (likeOperator) {
                (_b = filter.operator) !== null && _b !== void 0 ? _b : (filter.operator = {});
                filter.operator[type_1.FilterOperatorLabel.LIKE] = likeOperator;
                filter.value = filter.value.slice(1);
            }
            const inOperator = filter.value.includes(type_1.FilterOperator.IN);
            if (inOperator) {
                (_c = filter.operator) !== null && _c !== void 0 ? _c : (filter.operator = {});
                filter.operator[type_1.FilterOperatorLabel.IN] = true;
            }
            if (typeof filter.operator !== 'undefined') {
                filter.value = filter.operator[type_1.FilterOperatorLabel.IN] ? filter.value.split(',') : filter.value;
            }
        }
        items.push(filter);
    }
    return items;
}
exports.parseQueryFilters = parseQueryFilters;
//# sourceMappingURL=parse.js.map